/**
 * Penetration Test: Rate Limit Bypass Attempts
 *
 * This test verifies that the application's rate limiting cannot be bypassed
 * through various attack techniques.
 *
 * Test Scenarios:
 * 1. Distributed attack (multiple user IDs)
 * 2. Timing attacks (requests near TTL expiry)
 * 3. Race conditions (concurrent requests)
 * 4. Redis manipulation (direct key access)
 * 5. Request flooding (connection exhaustion)
 *
 * Expected Results:
 * - Rate limit enforced consistently across all attack vectors
 * - Redis atomic operations prevent race conditions
 * - TTL transitions handled cleanly (no exploitation window)
 * - Direct Redis access is only viable attack (mitigated by firewall)
 * - Connection limits prevent flooding (if configured)
 *
 * @see docs/SECURITY_AUDIT.md#test-3-rate-limit-bypass-attempts
 */

import { describe, it, expect, beforeEach, afterEach } from "vitest";
import { redis } from "../../src/utils/redis.js";
import {
  isUnlockRateLimited,
  recordUnlockFailure,
  clearUnlockFailures,
  MAX_UNLOCK_ATTEMPTS,
} from "../../src/services/security/unlockRateLimiter.js";

describe("Penetration Test: Rate Limit Bypass Attempts", () => {
  const TEST_USER_PREFIX = "pentest-ratelimit-";

  beforeEach(async () => {
    // Clean up any existing test keys
    const pattern = `unlock:attempts:${TEST_USER_PREFIX}*`;
    const keys = await redis.keys(pattern);
    if (keys.length > 0) {
      await redis.del(...keys);
    }
  });

  afterEach(async () => {
    // Clean up test keys
    const pattern = `unlock:attempts:${TEST_USER_PREFIX}*`;
    const keys = await redis.keys(pattern);
    if (keys.length > 0) {
      await redis.del(...keys);
    }
  });

  describe("Test 1: Distributed Attack (Multiple User IDs)", () => {
    it("should enforce rate limit per user independently", async () => {
      const userCount = 10;
      const users = Array.from({ length: userCount }, (_, i) => `${TEST_USER_PREFIX}user${i}`);

      // Each user attempts 10 unlocks (should be rate limited after 5)
      for (const userId of users) {
        for (let attempt = 0; attempt < 10; attempt++) {
          const status = await isUnlockRateLimited(userId);

          if (!status.blocked) {
            await recordUnlockFailure(userId);
          }
        }
      }

      // Verify each user is rate limited independently
      for (const userId of users) {
        const status = await isUnlockRateLimited(userId);

        expect(status.blocked).toBe(true);
        expect(status.attempts).toBe(MAX_UNLOCK_ATTEMPTS);
      }

      // Verify attacker cannot bypass by rotating user IDs
      // (Each user ID has its own rate limit counter)
    });

    it("should not allow cross-user rate limit interference", async () => {
      const user1 = `${TEST_USER_PREFIX}alice`;
      const user2 = `${TEST_USER_PREFIX}bob`;

      // User 1 triggers rate limit
      for (let i = 0; i < MAX_UNLOCK_ATTEMPTS; i++) {
        await recordUnlockFailure(user1);
      }

      // Verify user 1 is blocked
      const status1 = await isUnlockRateLimited(user1);
      expect(status1.blocked).toBe(true);

      // Verify user 2 is NOT affected
      const status2 = await isUnlockRateLimited(user2);
      expect(status2.blocked).toBe(false);
      expect(status2.attempts).toBe(0);
    });
  });

  describe("Test 2: Timing Attacks (TTL Expiry Exploitation)", () => {
    it("should handle requests during TTL expiry cleanly", async () => {
      const userId = `${TEST_USER_PREFIX}timing`;

      // Trigger rate limit
      for (let i = 0; i < MAX_UNLOCK_ATTEMPTS; i++) {
        await recordUnlockFailure(userId);
      }

      // Set TTL to 2 seconds (simulate near-expiry)
      const key = `unlock:attempts:${userId}`;
      await redis.expire(key, 2);

      // Launch concurrent requests near expiry
      const promises = Array.from({ length: 20 }, async () => {
        await new Promise((resolve) => setTimeout(resolve, Math.random() * 2000));
        const status = await isUnlockRateLimited(userId);
        return {
          timestamp: Date.now(),
          blocked: status.blocked,
          attempts: status.attempts,
        };
      });

      const results = await Promise.all(promises);

      // Verify no exploitation window exists
      // Some requests should see blocked=true (before expiry)
      // Some should see blocked=false (after expiry)
      const blockedCount = results.filter((r) => r.blocked).length;
      const allowedCount = results.filter((r) => !r.blocked).length;

      expect(blockedCount + allowedCount).toBe(20);

      // There should be a clean transition (no partial state)
      // Either rate limited OR not rate limited (no in-between)
      results.forEach((result) => {
        if (result.blocked) {
          expect(result.attempts).toBeGreaterThanOrEqual(MAX_UNLOCK_ATTEMPTS);
        } else {
          // After expiry, counter should be 0 (key deleted by Redis)
          expect(result.attempts).toBe(0);
        }
      });
    });

    it("should not allow rapid requests to bypass rate limit during TTL window", async () => {
      const userId = `${TEST_USER_PREFIX}rapid`;

      // Trigger rate limit with minimal delays
      const results = [];

      for (let i = 0; i < 20; i++) {
        const status = await isUnlockRateLimited(userId);
        results.push(status);

        if (!status.blocked) {
          await recordUnlockFailure(userId);
        }

        // Minimal delay (simulate rapid-fire attack)
        await new Promise((resolve) => setTimeout(resolve, 10));
      }

      // Should block after MAX_UNLOCK_ATTEMPTS attempts
      const blockedResults = results.filter((r) => r.blocked);
      expect(blockedResults.length).toBeGreaterThan(0);

      // Final state should be blocked
      const finalStatus = await isUnlockRateLimited(userId);
      expect(finalStatus.blocked).toBe(true);
    });
  });

  describe("Test 3: Race Conditions (Concurrent Requests)", () => {
    it("should handle concurrent INCR operations atomically", async () => {
      const userId = `${TEST_USER_PREFIX}concurrent`;

      // Launch 100 concurrent recordUnlockFailure calls
      const promises = Array.from({ length: 100 }, () =>
        recordUnlockFailure(userId)
      );

      await Promise.all(promises);

      // Verify count is exactly 100 (no race condition lost updates)
      const status = await isUnlockRateLimited(userId);
      expect(status.attempts).toBe(100);

      // Redis INCR is atomic, so no lost updates possible
    });

    it("should prevent race condition in TTL setting", async () => {
      const userId = `${TEST_USER_PREFIX}ttl-race`;

      // Launch concurrent recordUnlockFailure calls (first call sets TTL)
      const promises = Array.from({ length: 10 }, () =>
        recordUnlockFailure(userId)
      );

      await Promise.all(promises);

      // Verify TTL was set correctly (should exist and be >0)
      const key = `unlock:attempts:${userId}`;
      const ttl = await redis.ttl(key);

      // TTL should be set (not -1 for no expiry, not -2 for key doesn't exist)
      expect(ttl).toBeGreaterThan(0);
      expect(ttl).toBeLessThanOrEqual(900); // 15 minutes
    });

    it("should handle concurrent rate limit checks safely", async () => {
      const userId = `${TEST_USER_PREFIX}check-race`;

      // Pre-fill with 4 attempts (close to limit)
      for (let i = 0; i < 4; i++) {
        await recordUnlockFailure(userId);
      }

      // Launch 20 concurrent rate limit checks
      // Using atomic API to prevent race conditions
      const promises = Array.from({ length: 20 }, async () => {
        // Atomic increment AND check - no race condition
        const failureInfo = await recordUnlockFailure(userId);

        if (failureInfo.blocked) {
          return "blocked";
        } else {
          return "recorded";
        }
      });

      const results = await Promise.all(promises);

      // At most 1 request should succeed (the one that got attempt #5)
      const recordedCount = results.filter((r) => r === "recorded").length;
      expect(recordedCount).toBeLessThanOrEqual(1);

      // Final state should be blocked
      const finalStatus = await isUnlockRateLimited(userId);
      expect(finalStatus.blocked).toBe(true);
    });
  });

  describe("Test 4: Redis Manipulation (Direct Access Attack)", () => {
    it("should detect if attacker deletes rate limit key", async () => {
      const userId = `${TEST_USER_PREFIX}delete`;

      // Trigger rate limit
      for (let i = 0; i < MAX_UNLOCK_ATTEMPTS; i++) {
        await recordUnlockFailure(userId);
      }

      // Verify blocked
      let status = await isUnlockRateLimited(userId);
      expect(status.blocked).toBe(true);

      // ⚠️ ATTACK: Attacker with Redis access deletes key
      const key = `unlock:attempts:${userId}`;
      await redis.del(key);

      // Verify rate limit is now bypassed
      status = await isUnlockRateLimited(userId);
      expect(status.blocked).toBe(false);
      expect(status.attempts).toBe(0);

      // ✅ SECURITY FINDING: Direct Redis access CAN bypass rate limit
      // Mitigation: Lock down Redis with firewall (localhost only)
      //   ufw deny 6379/tcp
      //   ufw allow from 127.0.0.1 to any port 6379 proto tcp
    });

    it("should detect if attacker sets rate limit counter to 0", async () => {
      const userId = `${TEST_USER_PREFIX}reset`;

      // Trigger rate limit
      for (let i = 0; i < MAX_UNLOCK_ATTEMPTS; i++) {
        await recordUnlockFailure(userId);
      }

      // Verify blocked
      let status = await isUnlockRateLimited(userId);
      expect(status.blocked).toBe(true);

      // ⚠️ ATTACK: Attacker resets counter
      const key = `unlock:attempts:${userId}`;
      await redis.set(key, "0");

      // Verify rate limit is now bypassed
      status = await isUnlockRateLimited(userId);
      expect(status.blocked).toBe(false);
      expect(status.attempts).toBe(0);

      // ✅ SECURITY FINDING: Counter manipulation bypasses rate limit
      // Mitigation: Redis access control is CRITICAL
    });

    it("should detect if attacker extends TTL", async () => {
      const userId = `${TEST_USER_PREFIX}extend-ttl`;

      // Record 1 failure
      await recordUnlockFailure(userId);

      // Get initial TTL
      const key = `unlock:attempts:${userId}`;
      const initialTTL = await redis.ttl(key);
      expect(initialTTL).toBeGreaterThan(0);

      // ⚠️ ATTACK: Attacker extends TTL to prevent expiry
      await redis.expire(key, 999999); // ~11 days

      // Verify TTL was extended
      const extendedTTL = await redis.ttl(key);
      expect(extendedTTL).toBeGreaterThan(900);

      // ✅ SECURITY FINDING: TTL manipulation possible with Redis access
      // Impact: DoS (user locked out longer than intended)
    });
  });

  describe("Test 5: IP-Based Rate Limiting (Not Implemented)", () => {
    it("should document lack of IP-based rate limiting", () => {
      // ⚠️ SECURITY FINDING: No IP-based rate limiting implemented
      //
      // Current implementation:
      // - Rate limiting is per user ID (Telegram user ID)
      // - Telegram Bot API does not expose client IP addresses
      // - Attacker can create multiple Telegram accounts to bypass
      //
      // Recommendations:
      // 1. Implement Telegram account age verification (block new accounts)
      // 2. Monitor for suspicious patterns (multiple accounts from same device)
      // 3. Deploy behind Cloudflare (Layer 7 rate limiting)
      // 4. Consider CAPTCHA for repeated failures
      //
      // Trade-off:
      // - IP-based limiting not feasible with Telegram Bot API
      // - User-based limiting is best available option

      expect(true).toBe(true); // Documentation test (always passes)
    });
  });

  describe("Test 6: Session-Based Bypass Attempts", () => {
    it("should enforce rate limit even with valid session", async () => {
      const userId = `${TEST_USER_PREFIX}session`;

      // Trigger rate limit
      for (let i = 0; i < MAX_UNLOCK_ATTEMPTS; i++) {
        await recordUnlockFailure(userId);
      }

      // Verify blocked
      const status = await isUnlockRateLimited(userId);
      expect(status.blocked).toBe(true);

      // Even if user has valid session from previous login,
      // they cannot unlock additional wallets until rate limit expires
      // (Rate limit check happens BEFORE password verification)

      // This prevents:
      // - Brute-forcing other users' wallets
      // - Rapidly creating/unlocking multiple wallets
    });
  });

  describe("Test 7: Cleanup and Recovery", () => {
    it("should clear rate limit on successful unlock", async () => {
      const userId = `${TEST_USER_PREFIX}cleanup`;

      // Record 3 failures (below limit)
      for (let i = 0; i < 3; i++) {
        await recordUnlockFailure(userId);
      }

      // Verify attempts tracked
      let status = await isUnlockRateLimited(userId);
      expect(status.attempts).toBe(3);
      expect(status.blocked).toBe(false);

      // Simulate successful unlock (clear counter)
      await clearUnlockFailures(userId);

      // Verify counter reset
      status = await isUnlockRateLimited(userId);
      expect(status.attempts).toBe(0);
      expect(status.blocked).toBe(false);

      // ✅ SECURITY: Failed attempts don't persist after successful login
      // This prevents accumulation of old failures affecting future logins
    });

    it("should allow admin to manually reset rate limit", async () => {
      const userId = `${TEST_USER_PREFIX}admin-reset`;

      // Trigger rate limit
      for (let i = 0; i < MAX_UNLOCK_ATTEMPTS; i++) {
        await recordUnlockFailure(userId);
      }

      // Verify blocked
      let status = await isUnlockRateLimited(userId);
      expect(status.blocked).toBe(true);

      // Admin resets (legitimate recovery operation)
      await clearUnlockFailures(userId);

      // Verify reset successful
      status = await isUnlockRateLimited(userId);
      expect(status.blocked).toBe(false);
      expect(status.attempts).toBe(0);

      // ✅ OPERATIONAL: Admins can recover locked accounts
      // Use case: User legitimately forgot password, retried, got locked out
    });
  });

  describe("Test 8: Performance Under Load", () => {
    it("should maintain rate limiting accuracy under high concurrent load", async () => {
      const userId = `${TEST_USER_PREFIX}load`;

      // Launch 1000 concurrent attempts
      const promises = Array.from({ length: 1000 }, async () => {
        const status = await isUnlockRateLimited(userId);

        if (!status.blocked) {
          await recordUnlockFailure(userId);
        }

        return status;
      });

      await Promise.all(promises);

      // Final counter should be consistent (no lost updates)
      const finalStatus = await isUnlockRateLimited(userId);

      // Should have recorded all 1000 attempts (Redis atomic INCR)
      expect(finalStatus.attempts).toBe(1000);
      expect(finalStatus.blocked).toBe(true);
    });
  });
});
